
#pragma kernel ComputePosition
#pragma kernel SetIniSizeBuffer
#pragma kernel AdjustIniPos
#pragma kernel UpdatePosCounter
#include "Utils.cginc"


RWTexture2D <float4> _texture;
RWStructuredBuffer<float2> _positionsBuffer;
RWStructuredBuffer<int> _globalTreeCountPositionsBuffer;

RWTexture2D <float2> _positionsTexture;

RWStructuredBuffer<QuadTreeInfo> _qti;

//Store initial position and  amount of positions per node in NodePool 
RWStructuredBuffer<float2> _globalPosTreeIniSizeBuffer;

int _globalMaxPositionBufferSize;
int _myIdInNodePool;
int _globalNodePoolSize;
int _globalTreePoolSize;
int _globalCurvesDiscretizedBlockSize;
float _globalTerrainSize;


RWStructuredBuffer<float> _locked;

Texture2D<float> TexHeight;
Texture2D<float> TexWater;
RWTexture2D<float> TexMoisture;
RWTexture2D<float> TexSlope;

float GetHeight(float2 pos)
{
	return TexHeight[pos].x;
}


float GetObstacles(float2 pos)
{
	return 1 - TexWater[pos].x;
}


float GetSlope(float2 pos)
{
	return TexSlope[pos].x;
}


float GetMoisture(float2 pos)
{
	return TexMoisture[pos].x;
}


float EvaluateCurves(float2 pos, float2 pos01, float upperLevelInfo, int indexInTreePool, int vegLevel)
{
	return 1;
	int arrayOffset = indexInTreePool * _globalCurvesDiscretizedBlockSize;

	if (pos.x < 10 || pos.x > 1010 || pos.y < 10 || pos.y > 1010)	return 0;

	pos = WorldCoord2TexCoord(pos);

	int currentIndexHumidity = _globalCurvesDiscretizedBlockSize * GetMoisture(pos);
	int currentIndexHeight = _globalCurvesDiscretizedBlockSize * GetHeight(pos);
	int currentIndexSlope = _globalCurvesDiscretizedBlockSize * Remap(GetSlope(pos), 0, 0.4, 0, 1);

	float height = _globalTreeHeightInfo[arrayOffset + currentIndexHeight];
	//float moisture = _globalTreeHumidityInfo[arrayOffset + currentIndexHumidity];
	float slope = _globalTreeSlopeInfo[arrayOffset + currentIndexSlope];


	float avg = slope;
	avg /= 1.0;

	if (avg < 0.3)	return 0;

	return 1;
}



int EvaluatePosition(float2 wPos, float2 pos01)
{
	float radius = 3;
	//float2 uv0 = WorldPosition2AtlasInfoUpperLevelUV(_qti[0], wPos);
	//float2 uv1 = WorldPosition2AtlasInfoUpperLevelUV(_qti[0], wPos + float2(radius, radius));
	//float2 uv2 = WorldPosition2AtlasInfoUpperLevelUV(_qti[0], wPos + float2(-radius, radius));
	//float2 uv3 = WorldPosition2AtlasInfoUpperLevelUV(_qti[0], wPos + float2(radius, -radius));
	//float2 uv4 = WorldPosition2AtlasInfoUpperLevelUV(_qti[0], wPos + float2(-radius, -radius));

	float upperLevelInfo = 0;//_texture[uv0].r + _texture[uv1].r + _texture[uv2].r + _texture[uv3].r + _texture[uv4].r;

	//float2 uv = WorldPosition2AtlasInfoUpperLevelUV(_qti[0], wPos);
	//float upperLevelInfo = _texture[uv].r;

	//if(_qti[0].vegLevel > 1 && upperLevelInfo/5 > 0.15)	return 0;


	int r = CustomRand(wPos, 0, 30);


	int currentIndex = _globalTreeCountPositionsBuffer[r];

	if(currentIndex > _globalMaxPositionBufferSize)	return 0;

	//if(EvaluateCurves(wPos, pos01, upperLevelInfo, r, _qti[0].vegLevel) > frac(wPos.x))
	if(EvaluateCurves(wPos, pos01, upperLevelInfo, r, _qti[0].vegLevel) == 0)
		return 0;

	_globalTreeCountPositionsBuffer[r]++;
	
	_positionsTexture[float2(currentIndex, r)] = float2(wPos.x, wPos.y);

	_globalPosTreeIniSizeBuffer[_globalTreePoolSize * _myIdInNodePool + r].y ++;

	return 1;
}






[numthreads(1,1,1)]
void SetIniSizeBuffer (uint3 id : SV_DispatchThreadID)
{
	int iOffset = _globalTreePoolSize * _myIdInNodePool;

	for(int i = 0; i<_globalTreePoolSize; i++)
	{
		_globalPosTreeIniSizeBuffer[iOffset + i].x = _globalTreeCountPositionsBuffer[i];
		_globalPosTreeIniSizeBuffer[iOffset + i].y = 0;
	}
}




[numthreads(1,1,1)]
void ComputePosition (uint3 id : SV_DispatchThreadID)
{
	int NUM_THREAD = 1;

	int init = id.x * (BLOCK_SIZE / NUM_THREAD);
	int size = init + (BLOCK_SIZE / NUM_THREAD);

	for(int i = init; i < size; i++)
	{
		_positionsBuffer[i] = NormalizedPos2ScaledWorldPos(	_GlobalPrecomputedPositionL1[i], 
															_qti[0].currentNodeWorldOrigin, 
															_qti[0].currentNodeWorldSize);

		_positionsBuffer[i] *= EvaluatePosition(_positionsBuffer[i], _GlobalPrecomputedPositionL1[i]);
	}
}




[numthreads(1000,1,1)]
void AdjustIniPos(uint3 id : SV_DispatchThreadID)
{
	int NUM_THREAD = 1000;

	int init = id.x * (_globalNodePoolSize / NUM_THREAD);
	int size = init + (_globalNodePoolSize / NUM_THREAD);

	int delOffset = _myIdInNodePool * _globalTreePoolSize;

	for(int i = init; i < size; i++)
	{
		for(int j = 0; j < _globalTreePoolSize; j++)
		{
			int delBlockIni		= _globalPosTreeIniSizeBuffer[delOffset + j].x;
			int updateBlockIni	= _globalPosTreeIniSizeBuffer[i * _globalTreePoolSize + j].x;

			if(delBlockIni < updateBlockIni)
			{
				_globalPosTreeIniSizeBuffer[i * _globalTreePoolSize + j].x -= _globalPosTreeIniSizeBuffer[delOffset + j].y;
			}
		}
	}
}




[numthreads(1,1,1)]
void UpdatePosCounter()
{
	for(int i = 0; i < _globalTreePoolSize; i++)
	{
		_globalTreeCountPositionsBuffer[i] -= 
		_globalPosTreeIniSizeBuffer[_myIdInNodePool * _globalTreePoolSize + i].y;

		_globalPosTreeIniSizeBuffer[_myIdInNodePool * _globalTreePoolSize + i].y = 0;
	}
}

