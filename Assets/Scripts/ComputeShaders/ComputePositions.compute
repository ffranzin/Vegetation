
#pragma kernel ComputePosition
#pragma kernel SetIniSizeBuffer
#pragma kernel AdjustIniPos
#pragma kernel UpdatePosCounter
#pragma kernel GetPosition
#include "Utils.cginc"


Texture2D <float4> _texture;
RWStructuredBuffer<float2> _positionsBuffer;
RWStructuredBuffer<int> _globalTreeCountPositionsBuffer;

RWTexture2D <float2> _positionsTexture;

StructuredBuffer<QuadTreeInfo> _qti;

//Store initial position and  amount of positions per node in NodePool 
RWStructuredBuffer<int2> _globalPosTreeIniSizeBuffer;

int _globalMaxPositionBufferSize;
int _myIdInNodePool;
int _globalNodePoolSize;
int _globalTreePoolSize;
int _globalCurvesDiscretizedBlockSize;
float _globalTerrainSize;


Texture2D<float> TexHeight;
Texture2D<float> TexWater;
Texture2D<float> TexMoisture;
Texture2D<float> TexSlope;



float GetHeight(float2 pos, int indexInTreePool)
{
	//return TexHeight[pos].x;
	int o = indexInTreePool * _globalCurvesDiscretizedBlockSize;

	int i = clamp(0, _globalCurvesDiscretizedBlockSize, _globalCurvesDiscretizedBlockSize * TexHeight[pos].x);

	return  _globalTreeHeightInfo[i + o];
}


float GetObstacles(float2 pos)
{
	return 1 - ceil(TexWater[pos].x);
}



float GetMoisture(float2 pos, int indexInTreePool)
{
	//return TexMoisture[pos].x;
	int o = indexInTreePool * _globalCurvesDiscretizedBlockSize;

	int i = clamp(0, _globalCurvesDiscretizedBlockSize, _globalCurvesDiscretizedBlockSize * TexMoisture[pos].x);

	return _globalTreeHumidityInfo[i + o];
}


float GetSlope(float2 pos, int indexInTreePool)
{
	int o = indexInTreePool * _globalCurvesDiscretizedBlockSize;

	int i = clamp(0, _globalCurvesDiscretizedBlockSize, _globalCurvesDiscretizedBlockSize * TexSlope[pos].x);

	return  _globalTreeSlopeInfo[i + o];

	return TexSlope[pos].x;
}


float GetSensitive(float sens, int indexInTreePool)
{
	int o = indexInTreePool * _globalCurvesDiscretizedBlockSize;

	int i = clamp(0, _globalCurvesDiscretizedBlockSize, _globalCurvesDiscretizedBlockSize * sens);

	return  _globalTreeSensitiveInfo[i + o];
}




int EvaluateCurves(float2 pos, float2 pos01, float upperLevelInfo, int indexInTreePool, int vegLevel)
{ 
	pos = WorldCoord2TexCoord(pos);

	if(pos.x < 24 || pos.y < 24 || pos.x > 1000 || pos.y > 1000)	return 0;
	
	float moisture = GetMoisture( pos,  indexInTreePool);
	float slope = GetSlope( pos,  indexInTreePool);
	float height = GetHeight(pos, indexInTreePool);
	float sens = GetSensitive(upperLevelInfo, indexInTreePool);

	if(vegLevel == 1)	sens = 1;
		
	if( sens *height * slope * moisture < frac(pos.x * pos01.x))	return 0;
	//if((sens * height * slope * moisture) < 0.1)	return 0;
	
	return GetObstacles(pos);
}



int BestTree(float2 wPos, float2 pos01, int upperLevelInfo, int vegLevel, int a, int b)
{
	if(EvaluateCurves(wPos, pos01, upperLevelInfo, a, _qti[0].vegLevel) == 0)
	{
		if(EvaluateCurves(wPos, pos01, upperLevelInfo, b, _qti[0].vegLevel) == 0)
			return -1;
		return b;
	}
	return a;
}




int EvaluatePosition(float2 wPos, float2 pos01)
{
	float upperLevelInfo = 0;
	if(_qti[0].vegLevel > 1 && false)
	{
		float radius = 3;
		float2 uv0 = WorldPosition2AtlasInfoUpperLevelUV(_qti[0], wPos);
		float2 uv1 = WorldPosition2AtlasInfoUpperLevelUV(_qti[0], wPos + float2(radius, radius));
		float2 uv2 = WorldPosition2AtlasInfoUpperLevelUV(_qti[0], wPos + float2(-radius, radius));
		float2 uv3 = WorldPosition2AtlasInfoUpperLevelUV(_qti[0], wPos + float2(radius, -radius));
		float2 uv4 = WorldPosition2AtlasInfoUpperLevelUV(_qti[0], wPos + float2(-radius, -radius));
		upperLevelInfo  = _texture[uv0].r + _texture[uv1].r + _texture[uv2].r + _texture[uv3].r + _texture[uv4].r;
	}
	
	//float2 uv = WorldPosition2AtlasInfoUpperLevelUV(_qti[0], wPos);
	//float upperLevelInfo = _texture[uv].r;

	if(_qti[0].vegLevel > 1 && upperLevelInfo/5 > 0.15)	return 0;

	int r;

	if(_qti[0].vegLevel == 1)
	{
		r = BestTree(wPos, pos01, upperLevelInfo, _qti[0].vegLevel, 0, 1);		
	}
	else
	{
		if(EvaluateCurves(wPos, pos01, upperLevelInfo, _qti[0].vegLevel, _qti[0].vegLevel) == 0) return 0;

		r =  _qti[0].vegLevel;
	}


	if(r < 0)	return 0;

	int currentIndex = _globalTreeCountPositionsBuffer[r];

	if(currentIndex > _globalMaxPositionBufferSize)	return 0;

	//InterlockedAdd(_globalTreeCountPositionsBuffer[r], 1);

	_globalTreeCountPositionsBuffer[r]++;
	_positionsTexture[float2(currentIndex, r)] = float2(wPos.x, wPos.y);

	//InterlockedAdd(_globalPosTreeIniSizeBuffer[_globalTreePoolSize * _myIdInNodePool + r].y, 1);
	_globalPosTreeIniSizeBuffer[_globalTreePoolSize * _myIdInNodePool + r].y ++;

	return 1;
}


[numthreads(1,1,1)]
void SetIniSizeBuffer (uint3 id : SV_DispatchThreadID)
{
	int iOffset = _globalTreePoolSize * _myIdInNodePool;

	_globalPosTreeIniSizeBuffer[iOffset + id.x].x = _globalTreeCountPositionsBuffer[id.x];
	_globalPosTreeIniSizeBuffer[iOffset + id.x].y = 0;
}



//[numthreads(BLOCK_SIZE, 1, 1)]
//void ComputePosition(uint3 id : SV_DispatchThreadID)
//{
//	_positionsBuffer[id.x] = NormalizedPos2ScaledWorldPos(_GlobalPrecomputedPositionL1[id.x],
//		_qti[0].currentNodeWorldOrigin,
//		_qti[0].currentNodeWorldSize);
//
//	_positionsBuffer[id.x] *= EvaluatePosition(_positionsBuffer[id.x], _GlobalPrecomputedPositionL1[id.x]);
//}


[numthreads(1,1,1)]
void ComputePosition (uint3 id : SV_DispatchThreadID)
{
	for(int i = 0; i< 3000; i++)
	{
		float p = 	_GlobalPrecomputedPositionL1[i];

		if(_qti[0].vegLevel == 2)	 p = _GlobalPrecomputedPositionL2[i];
		else if(_qti[0].vegLevel == 3) p = 	_GlobalPrecomputedPositionL3[i];

		_positionsBuffer[i] = NormalizedPos2ScaledWorldPos(	_GlobalPrecomputedPositionL1[i], 
														_qti[0].currentNodeWorldOrigin, 
														_qti[0].currentNodeWorldSize);

	 _positionsBuffer[i] *= EvaluatePosition(_positionsBuffer[i], _GlobalPrecomputedPositionL1[i]);
	}
	
}




[numthreads(1000,1,1)]
void AdjustIniPos(uint3 id : SV_DispatchThreadID)
{
	int NUM_THREAD = 1000;

	int init = id.x;
	int size = 1;// init + (_globalNodePoolSize / NUM_THREAD);

	int delOffset = _myIdInNodePool * _globalTreePoolSize;

	for (int j = 0; j < _globalTreePoolSize; j++)
	{
		int delBlockIni = _globalPosTreeIniSizeBuffer[delOffset + j].x;
		int updateBlockIni = _globalPosTreeIniSizeBuffer[init * _globalTreePoolSize + j].x;

		if (delBlockIni < updateBlockIni)
		{
			_globalPosTreeIniSizeBuffer[init * _globalTreePoolSize + j].x -= _globalPosTreeIniSizeBuffer[delOffset + j].y;
		}
	}


	/*int init = id.x * (_globalNodePoolSize / NUM_THREAD);
	int size = init + (_globalNodePoolSize / NUM_THREAD);

	int delOffset = _myIdInNodePool * _globalTreePoolSize;

	for(int i = init; i < size; i++)
	{
		for(int j = 0; j < _globalTreePoolSize; j++)
		{
			int delBlockIni		= _globalPosTreeIniSizeBuffer[delOffset + j].x;
			int updateBlockIni	= _globalPosTreeIniSizeBuffer[i * _globalTreePoolSize + j].x;

			if(delBlockIni < updateBlockIni)
			{
				_globalPosTreeIniSizeBuffer[i * _globalTreePoolSize + j].x -= _globalPosTreeIniSizeBuffer[delOffset + j].y;
			}
		}
	}*/
}




[numthreads(1,1,1)]
void UpdatePosCounter(uint3 id : SV_DispatchThreadID)
{
	_globalTreeCountPositionsBuffer[id.x] -=
		_globalPosTreeIniSizeBuffer[_myIdInNodePool * _globalTreePoolSize + id.x].y;

	_globalPosTreeIniSizeBuffer[_myIdInNodePool * _globalTreePoolSize + id.x].y = 0;

	_globalTreeCountPositionsBuffer[id.x] = 0;
		//_globalPosTreeIniSizeBuffer[_myIdInNodePool * _globalTreePoolSize + id.x].y;

	_globalPosTreeIniSizeBuffer[_myIdInNodePool * _globalTreePoolSize + id.x].y = 0;


	/*for(int i = 0; i < _globalTreePoolSize; i++)
	{
		_globalTreeCountPositionsBuffer[i] -= 
		_globalPosTreeIniSizeBuffer[_myIdInNodePool * _globalTreePoolSize + i].y;

		_globalPosTreeIniSizeBuffer[_myIdInNodePool * _globalTreePoolSize + i].y = 0;
	}*/



	
	


}


RWStructuredBuffer<float4> worldPositionBuffer;
int index;
int tree;

[numthreads(1,1,1)]
void GetPosition(uint3 id : SV_DispatchThreadID)
{
	float2 p = _positionsTexture[float2(index, tree)];

	float h = TexHeight[p].x;

	worldPositionBuffer[0] = float4(p.x, h, p.y, 0);
	
}
